// Copyright (c) 2017 Amazon.com, Inc. or its affiliates. All rights reserved.
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { showAuthModal } from './auth-modal';
import { CLOCK_SKEW, getEndpoint, getSessionStorageKey } from './util';
const MAX_ATTEMPTS = 3;
const MIDWAY_AUTH = 'Midway Authentication';
/** Enumerates the well-known errors that can occur. */
export var SentryError;
(function (SentryError) {
    /**
     * The Midway auth modal has failed to authenticate the user.
     * This error occurs when `followMidwayStepUp` and `followMidwayStepUpOptions.mode == 'modal'` are set, the user does not have a valid Midway session, and the modal encounters an error (e.g. popups are blocked).
     */
    SentryError["MIDWAY_AUTH_MODAL_FAILED"] = "AUTH_MODAL_FAILED";
    /**
     * The user has been redirected to Midway.
     * This error occurs when `followMidwayStepUp` is enabled, the user does not have a valid Midway session, and the redirect is not cancelled.
     */
    SentryError["MIDWAY_REDIRECT"] = "MIDWAY_REDIRECT";
    /**
     * The user has cancelled the redirect to Midway.
     * This error occurs when `followMidwayStepUp` and `followMidwayStepUpOptions.mode == 'modal'` are set, the user does not have a valid Midway session, and the redirect is cancelled.
     */
    SentryError["MIDWAY_REDIRECT_CANCELLED"] = "MIDWAY_REDIRECT_CANCELLED";
    /**
     * The endpoint is protected by Midway and the user does not have a valid Midway session (i.e. they must re-authenticate using a security key).
     * This error only occurs when `followMidwayStepUp` is disabled or when `failOnInvalidSession` is enabled.
     */
    SentryError["NO_MIDWAY_SESSION"] = "NO_MIDWAY_SESSION";
})(SentryError || (SentryError = {}));
/** An error object for NO_MIDWAY_SESSION */
export const NO_MIDWAY_SESSION_ERROR = Object.freeze(new Error(SentryError.NO_MIDWAY_SESSION));
export const configure = (sentryOptions = {}) => {
    return function configuredFetch(url, options) {
        return sentryFetch(url, Object.assign(Object.assign({}, options), { sentryOptions }));
    };
};
/**
 * Checks authentication before making desired request. If not authenticated, a new authentication token will be
 * requested and either validated or included with the request, depending on the server's configuration.
 */
export default function sentryFetch(url, options) {
    var _a;
    const _b = options || {}, { sentryOptions = {} } = _b, fetchOptions = __rest(_b, ["sentryOptions"]);
    const reqInfo = (url instanceof URL) ? url.toString() : url;
    const request = new Request(reqInfo, Object.assign(Object.assign({}, fetchOptions), { credentials: 'include' }));
    const endpoint = getEndpoint(request, sentryOptions.getEndpointOverride);
    const fetchFunction = (_a = sentryOptions.fetchFunction) !== null && _a !== void 0 ? _a : globalFetch;
    if (!sentryOptions.fetchFunction && window.fetch === sentryFetch) {
        throw new Error("window.fetch is overridden with sentryFetch and sentryOptions.fetchFunction is not set, " +
            "this will cause infinite loop, you should pass original window.fetch to sentryOptions.fetchFunction");
    }
    if (isAuthenticated(endpoint)) {
        // if we're here it means the session storage key timestamp is still valid
        // it does not mean the token cookie is still present (e.g. it may be have been manually deleted)
        // we cannot check the token cookie due to its `HttpOnly` flag
        // for performance reasons, we first try to do a `globalFetch` expecting the cookie to be present
        return fetchFunction(request.clone())
            .catch((error) => {
            if ((error === null || error === void 0 ? void 0 : error.name) === 'AbortError') {
                // request was cancelled, do not attempt to reauthenticate
                return Promise.reject(error);
            }
            // if we're here it means the request failed at a network level (e.g. DNS error) or there was a CORS error
            // requests with no token cookie receive a redirect response with no CORS headers
            // the browser does not tell the difference between the two errors, so we assume a CORS error and we try to authenticate again
            if (sentryOptions.debug) {
                console.warn('[SentryFetch] Unexpected fetch error for authenticated endpoint. Trying to authenticate again...');
            }
            clearAuthenticationCache(endpoint);
            return performAuthenticationSteps(endpoint, request, sentryOptions);
        });
    }
    return performAuthenticationSteps(endpoint, request, sentryOptions);
}
function globalFetch(...args) {
    return window.fetch(...args);
}
function performAuthenticationSteps(endpoint, req, sentryOptions) {
    var _a;
    const fetchFunction = (_a = sentryOptions.fetchFunction) !== null && _a !== void 0 ? _a : globalFetch;
    function perform(attempt = 1) {
        // for every attempt, request has to be cloned
        // so that retry will be able to retry with unused request
        const request = req.clone();
        if (attempt > MAX_ATTEMPTS) {
            return fetchFunction(request);
        }
        return new Promise((resolve, reject) => {
            const retry = () => perform(attempt + 1).then(resolve).catch(reject);
            authenticate(endpoint, fetchFunction)
                .then((authData) => {
                if (authData.is_authenticated === true) {
                    cacheAuthentication(endpoint, authData.expires_at);
                    makeOriginalRequest(request, fetchFunction, authData.token)
                        .then(resolve).catch(retry);
                    return;
                }
                fetchTokenAndAuthenticate(authData, request.url, endpoint, sentryOptions)
                    .then((authData) => {
                    // if `authData.is_authenticated === true` it means we are using
                    // cookies, so we can cache the authentication
                    if (authData.is_authenticated) {
                        cacheAuthentication(endpoint, authData.expires_at);
                    }
                    // `authData.token` will have a value only when cookies are not used
                    return makeOriginalRequest(request, fetchFunction, authData.token);
                })
                    .then(resolve)
                    .catch(err => {
                    switch (err.message) {
                        // non-retryable errors
                        case SentryError.NO_MIDWAY_SESSION:
                        case SentryError.MIDWAY_AUTH_MODAL_FAILED:
                        case SentryError.MIDWAY_REDIRECT:
                        case SentryError.MIDWAY_REDIRECT_CANCELLED:
                            reject(err);
                            break;
                        default:
                            retry();
                    }
                });
            })
                .catch(reject);
        });
    }
    return perform();
}
function makeOriginalRequest(request, fetchFunction, token) {
    if (token) {
        // The fetch api does not make it easy to copy a request changing it's url.
        //
        // https://github.com/whatwg/fetch/issues/191
        // https://github.com/whatwg/fetch/issues/245
        return request.blob()
            .then(body => {
            // Some request methods do not allow bodies (GET, HEAD, OPTIONS), but
            // request body methods (text(), blob(), json()) _always_ return an
            // object. If the request was created without a body they will return
            // empty string, or size 0. Requests that do not allow bodies will
            // throw if a body is included, even if it is an empty string.
            //
            //
            //    const get = new Request('/example');
            //
            //    // Body is empty string
            //    const body = await get.text()
            //
            //    // Error, GET requests don't allow bodies!
            //    const copy = new Request('/example', {body});
            //
            // We return `undefined` when bodies are empty because it avoids
            // exceptions when the method does not allow bodies, and it should be
            // safe because:
            // - the HTTP protocol cannot differentiate null body from empty body
            // - the Fetch api coerces undefined bodies to empty.
            return body.size > 0 ? body : undefined;
        })
            .then(body => {
            // Using the two-argument Request constructor will copy everything in the
            // request except body, and may throw if the request to copy has elevated
            // privilege.
            //
            // Here we copy the request once to change the url, then again to set the
            // body. The body must be read asynchronously from the old request.
            const tokenRequest = new Request(addParam(request.url, 'id_token', token), request);
            return new Request(tokenRequest, { body });
        })
            .then(fetchFunction);
    }
    else {
        return fetchFunction(request);
    }
}
function fetchTokenAndAuthenticate(authData, url, endpoint, sentryOptions) {
    var _a;
    const fetchFunction = (_a = sentryOptions.fetchFunction) !== null && _a !== void 0 ? _a : globalFetch;
    const sentryUrl = (sentryOptions === null || sentryOptions === void 0 ? void 0 : sentryOptions.preserveRedirectUri) ? authData.authn_endpoint
        : replaceRedirectUri(authData.authn_endpoint, url);
    if (authData.no_cookie_token) {
        return fetchToken(sentryUrl, endpoint, sentryOptions).then(token => ({ token }));
    }
    return fetchToken(sentryUrl, endpoint, sentryOptions)
        .then(token => authenticate(endpoint, fetchFunction, token))
        .then(authentication => {
        if (authentication.is_authenticated) {
            return authentication;
        }
        throw new Error('Failed to authenticate');
    });
}
function fetchToken(url, endpoint, sentryOptions) {
    var _a;
    const fetchFunction = (_a = sentryOptions.fetchFunction) !== null && _a !== void 0 ? _a : globalFetch;
    return debounceRequest(`sentry:${endpoint}`, () => {
        return fetchFunction(url, { credentials: 'include' })
            .then(handleNotOk)
            .then(
        // 2XX response: text/plain response with id_token
        response => response.text(), 
        // other response: application/json response with step-up or other
        response => response.json().then(
        // response body is JSON
        (jsonError) => {
            if (jsonError.step_up_methods) {
                if (sentryOptions.followMidwayStepUp) {
                    const midwayStepUp = jsonError.step_up_methods.find(method => method.cap_name === MIDWAY_AUTH);
                    if (midwayStepUp) {
                        return followMidwayStepUp(midwayStepUp, url, endpoint, sentryOptions);
                    }
                }
                else {
                    throw new Error(SentryError.NO_MIDWAY_SESSION);
                }
            }
            // response body is not step-up
            throw new Error(response.statusText);
        }, 
        // JSON parsing failed
        () => {
            throw new Error(response.statusText);
        }));
    });
}
function buildQueryStringMap(url) {
    const queryString = url.split('?')[1];
    return queryString.split('&').reduce((queryStringMap, queryStringElement) => {
        if (queryStringElement !== '') {
            const splitElement = queryStringElement.split('=');
            queryStringMap[splitElement[0]] = decodeURIComponent(splitElement[1]);
        }
        return queryStringMap;
    }, {});
}
function followMidwayStepUp(midwayStepUp, url, endpoint, sentryOptions) {
    var _a;
    const { followMidwayStepUpOptions: stepUpOptions, failOnInvalidSession } = sentryOptions;
    const fetchFunction = (_a = sentryOptions.fetchFunction) !== null && _a !== void 0 ? _a : globalFetch;
    if (stepUpOptions) {
        // if configured, show auth modal instead of redirecting
        if (stepUpOptions.mode === 'modal') {
            const doFetchToken = () => debounceRequest(`sentry:${endpoint}:fetch-token`, () => fetchFunction(url, { credentials: 'include' }).then(handleNotOk).then(res => res.text()).catch(res => {
                // A 400 response from Midway indicates that the session is invalid for the client_id.
                // In such cases, Midway won't issue a token for the client_id on the call to "/SSO" even though the user login was successful.
                // When using step up with a modal, failure to handle an invalid session means that the user will be blocked indefinitely behind the modal dialog.
                // The modal will not be cleaned up even when the Midway popup is closed because the session is still invalid for the client_id.
                // This breaks the customer experience for applications that prefer to recover from a failed Midway login and take a different path.
                // The option "failOnInvalidSession" solves this problem. It signals the modal to be cleaned up on error and returns the appropriate
                // exception which the caller can handle.
                if (failOnInvalidSession && res instanceof Response && res.status == 400) {
                    throw NO_MIDWAY_SESSION_ERROR;
                }
                return '';
            }));
            const { mode, createModal } = stepUpOptions, authModalOptions = __rest(stepUpOptions, ["mode", "createModal"]);
            return showAuthModal(midwayStepUp.cap_url, doFetchToken, authModalOptions, createModal).catch(err => {
                // if we receive a no midway session error, we should propagate it as is.
                if (err === NO_MIDWAY_SESSION_ERROR) {
                    return Promise.reject(NO_MIDWAY_SESSION_ERROR);
                }
                if (sentryOptions.debug) {
                    console.warn('[SentryFetch] An error ocurred while showing the auth modal.', err);
                }
                return Promise.reject(new Error(SentryError.MIDWAY_AUTH_MODAL_FAILED));
            });
        }
        // if configured, show confirmation dialog before redirect
        if (stepUpOptions.mode === 'confirm') {
            const msg = stepUpOptions.message || 'Your Midway session has expired. You will be redirected to Midway for authentication.';
            if (!window.confirm(msg)) {
                return Promise.reject(new Error(SentryError.MIDWAY_REDIRECT_CANCELLED));
            }
        }
    }
    const queryStringMap = buildQueryStringMap(url);
    let redirectUrl = '/SSO/redirect';
    queryStringMap['redirect_uri'] = window.location.href;
    queryStringMap['client_id'] = window.location.origin;
    if (typeof sentryOptions.followMidwayStepUp === 'string') {
        queryStringMap['acr_values'] = sentryOptions.followMidwayStepUp;
    }
    Object.keys(queryStringMap).forEach(queryParam => {
        redirectUrl = addParam(redirectUrl, queryParam, queryStringMap[queryParam]);
    });
    const midwayUrl = addParam(midwayStepUp.cap_url, 'next', redirectUrl);
    window.location.replace(midwayUrl);
    throw new Error(SentryError.MIDWAY_REDIRECT);
}
function authenticate(endpoint, fetchFunction, token) {
    return debounceRequest(endpoint, () => {
        return fetchFunction(addParam(`${endpoint}/sso/login`, 'id_token', token), { credentials: 'include' })
            .then(handleNotOk)
            .then(response => response.json())
            .catch(response => {
            throw new Error(response.statusText);
        });
    });
}
function handleNotOk(response) {
    if (!response.ok) {
        throw response;
    }
    return response;
}
const pendingRequests = {};
function debounceRequest(requestId, makeRequest) {
    if (pendingRequests[requestId]) {
        return pendingRequests[requestId];
    }
    const promise = makeRequest();
    pendingRequests[requestId] = promise;
    const unpend = () => delete pendingRequests[requestId];
    promise.then(unpend).catch(unpend);
    return promise;
}
const redirectUriParamRx = /&?redirect_uri=[^&]+/;
function replaceRedirectUri(url, value) {
    const base = url.replace(redirectUriParamRx, '');
    return addParam(base, 'redirect_uri', value);
}
function addParam(url, param, value) {
    if (!value) {
        return url;
    }
    const delim = url.includes('?') ? '&' : '?';
    return `${url}${delim}${param}=${encodeURIComponent(value)}`;
}
function isAuthenticated(endpoint) {
    const expiryTime = parseInt(sessionStorage.getItem(getSessionStorageKey(endpoint)), 10);
    return !isNaN(expiryTime) && new Date().getTime() < expiryTime;
}
function cacheAuthentication(endpoint, expiryTime) {
    const expiry = parseInt(expiryTime, 10);
    if (isNaN(expiry)) {
        return;
    }
    sessionStorage.setItem(getSessionStorageKey(endpoint), (expiry - CLOCK_SKEW).toString());
}
function clearAuthenticationCache(endpoint) {
    sessionStorage.removeItem(getSessionStorageKey(endpoint));
}
//# sourceMappingURL=index.js.map