import { createDefaultModal } from './default-auth-modal';
/**
 * Gets the origin from an URL.
 * @param url The URL to obtain the origin from.
 */
function getOrigin(url) {
    // [^\/]+ => while (char !== '/') { consume(char); }
    const originPattern = /^(https?:\/\/[^\/]+)/i;
    const match = originPattern.exec(url);
    if (!match) {
        throw new Error(`Invalid URL: ${url}`);
    }
    // https://midway-auth.amazon.com:443 => https://midway-auth.amazon.com:443
    // https://midway-auth.amazon.com/login => https://midway-auth.amazon.com
    return match[1];
}
let authWindow;
/**
 * Opens a window to authenticate with Midway.
 * @param windowUrl The URL that the window will load.
 * @param onUserWindowClose A callback that is invoked when the window is closed by the user.
 */
function showAuthWindow(windowUrl, onUserWindowClose) {
    if (authWindow) {
        // window is already open, focus instead
        return authWindow.focus();
    }
    // open window
    authWindow = window.open(windowUrl, 'Midway Authentication', 'height=800,width=800');
    if (!authWindow) {
        throw new Error('The auth window failed to open.');
    }
    // since this is a cross-origin window, we cannot use DOM events like `onbeforeunload` or `onunload`
    const checkIfClosedInterval = setInterval(() => {
        if (!authWindow || authWindow.closed) {
            clearInterval(checkIfClosedInterval);
            // check if the window was closed by the user
            if (authWindow) {
                authWindow = undefined;
                onUserWindowClose();
            }
        }
    }, 100);
}
/** Closes the authentication window. */
function closeAuthWindow() {
    if (authWindow) {
        authWindow.close();
        authWindow = undefined;
    }
}
let authWindowOrigin;
let authWindowUrl;
let ongoingPromise;
/** Function used for unit testing purposes. */
export function clearAuthWindowUrl() {
    authWindowUrl = undefined;
}
/**
 * Shows a modal asking users to authenticate with Midway using a popup.
 * Returns a `Promise` that resolves when the user has authenticated successfully with the auth token.
 * @param url The authentication URL to show.
 * @param fetchToken A callback that returns a `Promise` with the Midway token.
 * @param options The modal options.
 * @param createAuthModal A callback for creating a custom auth modal.
 */
export function showAuthModal(url, fetchToken, options, createAuthModal) {
    // there can only be one active modal at a time, different auth window URLs are not supported
    if (authWindowUrl && authWindowUrl !== url) {
        return Promise.reject(new Error('Cannot support two different auth window URLs at the same time.'));
    }
    // re-use promise if there's already one ongoing
    if (ongoingPromise) {
        return ongoingPromise;
    }
    try {
        authWindowOrigin = getOrigin(url);
    }
    catch (err) {
        // authUrl is not a valid URL
        return Promise.reject(err);
    }
    authWindowUrl = url;
    ongoingPromise = new Promise((resolve, reject) => {
        // callback that opens the auth window
        const openAuthWindow = () => {
            try {
                // if the user is already authenticated, no message will be sent from the window and `onMessage` will never trigger.
                // hence if the user closes the window, we check if the user is already authenticated and cleanup if so
                showAuthWindow(authWindowUrl, cleanupIfAuth);
            }
            catch (err) {
                // window failed to open (e.g. blocked popup)
                cleanup();
                reject(err);
            }
        };
        // create auth modal
        const createAuthModalOptions = Object.assign(Object.assign({}, options), { openAuthWindow });
        const modal = createAuthModal ? createAuthModal(createAuthModalOptions) : createDefaultModal(createAuthModalOptions);
        // message sent by auth window when auth finishes
        const onMessage = (e) => {
            if (e.origin === authWindowOrigin && e.data.event_type === 'auth_success') {
                cleanupIfAuth().catch(res => {
                    // at this point we're supposed to be authenticated
                    // if we got a non-successful response, we fail
                    if ((res instanceof Response) && !res.ok) {
                        cleanup();
                        reject(res);
                    }
                });
            }
        };
        // if the page was not visible and becomes visible again, the user may be already authenticated
        // check if the user is already authenticated and cleanup if so
        const onVisibilityChange = () => {
            if (!document.hidden) {
                cleanupIfAuth();
            }
        };
        // idempotent cleanup function
        let cleanup = () => {
            closeAuthWindow();
            document.removeEventListener('visibilitychange', onVisibilityChange);
            window.removeEventListener('message', onMessage);
            modal.close();
            authWindowOrigin = undefined;
            authWindowUrl = undefined;
        };
        // cleans up if user is already authenticated
        const cleanupIfAuth = () => fetchToken().then(token => {
            if (token) {
                cleanup();
                resolve(token);
            }
        }).catch(err => {
            // on error we must ensure to cleanup the modal and reject the request.
            cleanup();
            reject(err);
        });
        // register event listeners and add modal to DOM
        document.addEventListener('visibilitychange', onVisibilityChange);
        window.addEventListener('message', onMessage);
    });
    // clean `ongoingPromise`
    ongoingPromise
        .then(() => ongoingPromise = undefined)
        .catch(() => ongoingPromise = undefined);
    return ongoingPromise;
}
//# sourceMappingURL=auth-modal.js.map