"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.showAuthModal = exports.clearAuthWindowUrl = void 0;
var default_auth_modal_1 = require("./default-auth-modal");
/**
 * Gets the origin from an URL.
 * @param url The URL to obtain the origin from.
 */
function getOrigin(url) {
    // [^\/]+ => while (char !== '/') { consume(char); }
    var originPattern = /^(https?:\/\/[^\/]+)/i;
    var match = originPattern.exec(url);
    if (!match) {
        throw new Error("Invalid URL: " + url);
    }
    // https://midway-auth.amazon.com:443 => https://midway-auth.amazon.com:443
    // https://midway-auth.amazon.com/login => https://midway-auth.amazon.com
    return match[1];
}
var authWindow;
/**
 * Opens a window to authenticate with Midway.
 * @param windowUrl The URL that the window will load.
 * @param onUserWindowClose A callback that is invoked when the window is closed by the user.
 */
function showAuthWindow(windowUrl, onUserWindowClose) {
    if (authWindow) {
        // window is already open, focus instead
        return authWindow.focus();
    }
    // open window
    authWindow = window.open(windowUrl, 'Midway Authentication', 'height=800,width=800');
    if (!authWindow) {
        throw new Error('The auth window failed to open.');
    }
    // since this is a cross-origin window, we cannot use DOM events like `onbeforeunload` or `onunload`
    var checkIfClosedInterval = setInterval(function () {
        if (!authWindow || authWindow.closed) {
            clearInterval(checkIfClosedInterval);
            // check if the window was closed by the user
            if (authWindow) {
                authWindow = undefined;
                onUserWindowClose();
            }
        }
    }, 100);
}
/** Closes the authentication window. */
function closeAuthWindow() {
    if (authWindow) {
        authWindow.close();
        authWindow = undefined;
    }
}
var authWindowOrigin;
var authWindowUrl;
var ongoingPromise;
/** Function used for unit testing purposes. */
function clearAuthWindowUrl() {
    authWindowUrl = undefined;
}
exports.clearAuthWindowUrl = clearAuthWindowUrl;
/**
 * Shows a modal asking users to authenticate with Midway using a popup.
 * Returns a `Promise` that resolves when the user has authenticated successfully with the auth token.
 * @param url The authentication URL to show.
 * @param fetchToken A callback that returns a `Promise` with the Midway token.
 * @param options The modal options.
 * @param createAuthModal A callback for creating a custom auth modal.
 */
function showAuthModal(url, fetchToken, options, createAuthModal) {
    // there can only be one active modal at a time, different auth window URLs are not supported
    if (authWindowUrl && authWindowUrl !== url) {
        return Promise.reject(new Error('Cannot support two different auth window URLs at the same time.'));
    }
    // re-use promise if there's already one ongoing
    if (ongoingPromise) {
        return ongoingPromise;
    }
    try {
        authWindowOrigin = getOrigin(url);
    }
    catch (err) {
        // authUrl is not a valid URL
        return Promise.reject(err);
    }
    authWindowUrl = url;
    ongoingPromise = new Promise(function (resolve, reject) {
        // callback that opens the auth window
        var openAuthWindow = function () {
            try {
                // if the user is already authenticated, no message will be sent from the window and `onMessage` will never trigger.
                // hence if the user closes the window, we check if the user is already authenticated and cleanup if so
                showAuthWindow(authWindowUrl, cleanupIfAuth);
            }
            catch (err) {
                // window failed to open (e.g. blocked popup)
                cleanup();
                reject(err);
            }
        };
        // create auth modal
        var createAuthModalOptions = __assign(__assign({}, options), { openAuthWindow: openAuthWindow });
        var modal = createAuthModal ? createAuthModal(createAuthModalOptions) : default_auth_modal_1.createDefaultModal(createAuthModalOptions);
        // message sent by auth window when auth finishes
        var onMessage = function (e) {
            if (e.origin === authWindowOrigin && e.data.event_type === 'auth_success') {
                cleanupIfAuth().catch(function (res) {
                    // at this point we're supposed to be authenticated
                    // if we got a non-successful response, we fail
                    if ((res instanceof Response) && !res.ok) {
                        cleanup();
                        reject(res);
                    }
                });
            }
        };
        // if the page was not visible and becomes visible again, the user may be already authenticated
        // check if the user is already authenticated and cleanup if so
        var onVisibilityChange = function () {
            if (!document.hidden) {
                cleanupIfAuth();
            }
        };
        // idempotent cleanup function
        var cleanup = function () {
            closeAuthWindow();
            document.removeEventListener('visibilitychange', onVisibilityChange);
            window.removeEventListener('message', onMessage);
            modal.close();
            authWindowOrigin = undefined;
            authWindowUrl = undefined;
        };
        // cleans up if user is already authenticated
        var cleanupIfAuth = function () { return fetchToken().then(function (token) {
            if (token) {
                cleanup();
                resolve(token);
            }
        }).catch(function (err) {
            // on error we must ensure to cleanup the modal and reject the request.
            cleanup();
            reject(err);
        }); };
        // register event listeners and add modal to DOM
        document.addEventListener('visibilitychange', onVisibilityChange);
        window.addEventListener('message', onMessage);
    });
    // clean `ongoingPromise`
    ongoingPromise
        .then(function () { return ongoingPromise = undefined; })
        .catch(function () { return ongoingPromise = undefined; });
    return ongoingPromise;
}
exports.showAuthModal = showAuthModal;
//# sourceMappingURL=auth-modal.js.map