"use strict";
// Copyright (c) 2017 Amazon.com, Inc. or its affiliates. All rights reserved.
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.configure = exports.NO_MIDWAY_SESSION_ERROR = exports.SentryError = void 0;
var auth_modal_1 = require("./auth-modal");
var util_1 = require("./util");
var MAX_ATTEMPTS = 3;
var MIDWAY_AUTH = 'Midway Authentication';
/** Enumerates the well-known errors that can occur. */
var SentryError;
(function (SentryError) {
    /**
     * The Midway auth modal has failed to authenticate the user.
     * This error occurs when `followMidwayStepUp` and `followMidwayStepUpOptions.mode == 'modal'` are set, the user does not have a valid Midway session, and the modal encounters an error (e.g. popups are blocked).
     */
    SentryError["MIDWAY_AUTH_MODAL_FAILED"] = "AUTH_MODAL_FAILED";
    /**
     * The user has been redirected to Midway.
     * This error occurs when `followMidwayStepUp` is enabled, the user does not have a valid Midway session, and the redirect is not cancelled.
     */
    SentryError["MIDWAY_REDIRECT"] = "MIDWAY_REDIRECT";
    /**
     * The user has cancelled the redirect to Midway.
     * This error occurs when `followMidwayStepUp` and `followMidwayStepUpOptions.mode == 'modal'` are set, the user does not have a valid Midway session, and the redirect is cancelled.
     */
    SentryError["MIDWAY_REDIRECT_CANCELLED"] = "MIDWAY_REDIRECT_CANCELLED";
    /**
     * The endpoint is protected by Midway and the user does not have a valid Midway session (i.e. they must re-authenticate using a security key).
     * This error only occurs when `followMidwayStepUp` is disabled or when `failOnInvalidSession` is enabled.
     */
    SentryError["NO_MIDWAY_SESSION"] = "NO_MIDWAY_SESSION";
})(SentryError = exports.SentryError || (exports.SentryError = {}));
/** An error object for NO_MIDWAY_SESSION */
exports.NO_MIDWAY_SESSION_ERROR = Object.freeze(new Error(SentryError.NO_MIDWAY_SESSION));
exports.configure = function (sentryOptions) {
    if (sentryOptions === void 0) { sentryOptions = {}; }
    return function configuredFetch(url, options) {
        return sentryFetch(url, __assign(__assign({}, options), { sentryOptions: sentryOptions }));
    };
};
/**
 * Checks authentication before making desired request. If not authenticated, a new authentication token will be
 * requested and either validated or included with the request, depending on the server's configuration.
 */
function sentryFetch(url, options) {
    var _a;
    var _b = options || {}, _c = _b.sentryOptions, sentryOptions = _c === void 0 ? {} : _c, fetchOptions = __rest(_b, ["sentryOptions"]);
    var reqInfo = (url instanceof URL) ? url.toString() : url;
    var request = new Request(reqInfo, __assign(__assign({}, fetchOptions), { credentials: 'include' }));
    var endpoint = util_1.getEndpoint(request, sentryOptions.getEndpointOverride);
    var fetchFunction = (_a = sentryOptions.fetchFunction) !== null && _a !== void 0 ? _a : globalFetch;
    if (!sentryOptions.fetchFunction && window.fetch === sentryFetch) {
        throw new Error("window.fetch is overridden with sentryFetch and sentryOptions.fetchFunction is not set, " +
            "this will cause infinite loop, you should pass original window.fetch to sentryOptions.fetchFunction");
    }
    if (isAuthenticated(endpoint)) {
        // if we're here it means the session storage key timestamp is still valid
        // it does not mean the token cookie is still present (e.g. it may be have been manually deleted)
        // we cannot check the token cookie due to its `HttpOnly` flag
        // for performance reasons, we first try to do a `globalFetch` expecting the cookie to be present
        return fetchFunction(request.clone())
            .catch(function (error) {
            if ((error === null || error === void 0 ? void 0 : error.name) === 'AbortError') {
                // request was cancelled, do not attempt to reauthenticate
                return Promise.reject(error);
            }
            // if we're here it means the request failed at a network level (e.g. DNS error) or there was a CORS error
            // requests with no token cookie receive a redirect response with no CORS headers
            // the browser does not tell the difference between the two errors, so we assume a CORS error and we try to authenticate again
            if (sentryOptions.debug) {
                console.warn('[SentryFetch] Unexpected fetch error for authenticated endpoint. Trying to authenticate again...');
            }
            clearAuthenticationCache(endpoint);
            return performAuthenticationSteps(endpoint, request, sentryOptions);
        });
    }
    return performAuthenticationSteps(endpoint, request, sentryOptions);
}
exports.default = sentryFetch;
function globalFetch() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return window.fetch.apply(window, args);
}
function performAuthenticationSteps(endpoint, req, sentryOptions) {
    var _a;
    var fetchFunction = (_a = sentryOptions.fetchFunction) !== null && _a !== void 0 ? _a : globalFetch;
    function perform(attempt) {
        if (attempt === void 0) { attempt = 1; }
        // for every attempt, request has to be cloned
        // so that retry will be able to retry with unused request
        var request = req.clone();
        if (attempt > MAX_ATTEMPTS) {
            return fetchFunction(request);
        }
        return new Promise(function (resolve, reject) {
            var retry = function () { return perform(attempt + 1).then(resolve).catch(reject); };
            authenticate(endpoint, fetchFunction)
                .then(function (authData) {
                if (authData.is_authenticated === true) {
                    cacheAuthentication(endpoint, authData.expires_at);
                    makeOriginalRequest(request, fetchFunction, authData.token)
                        .then(resolve).catch(retry);
                    return;
                }
                fetchTokenAndAuthenticate(authData, request.url, endpoint, sentryOptions)
                    .then(function (authData) {
                    // if `authData.is_authenticated === true` it means we are using
                    // cookies, so we can cache the authentication
                    if (authData.is_authenticated) {
                        cacheAuthentication(endpoint, authData.expires_at);
                    }
                    // `authData.token` will have a value only when cookies are not used
                    return makeOriginalRequest(request, fetchFunction, authData.token);
                })
                    .then(resolve)
                    .catch(function (err) {
                    switch (err.message) {
                        // non-retryable errors
                        case SentryError.NO_MIDWAY_SESSION:
                        case SentryError.MIDWAY_AUTH_MODAL_FAILED:
                        case SentryError.MIDWAY_REDIRECT:
                        case SentryError.MIDWAY_REDIRECT_CANCELLED:
                            reject(err);
                            break;
                        default:
                            retry();
                    }
                });
            })
                .catch(reject);
        });
    }
    return perform();
}
function makeOriginalRequest(request, fetchFunction, token) {
    if (token) {
        // The fetch api does not make it easy to copy a request changing it's url.
        //
        // https://github.com/whatwg/fetch/issues/191
        // https://github.com/whatwg/fetch/issues/245
        return request.blob()
            .then(function (body) {
            // Some request methods do not allow bodies (GET, HEAD, OPTIONS), but
            // request body methods (text(), blob(), json()) _always_ return an
            // object. If the request was created without a body they will return
            // empty string, or size 0. Requests that do not allow bodies will
            // throw if a body is included, even if it is an empty string.
            //
            //
            //    const get = new Request('/example');
            //
            //    // Body is empty string
            //    const body = await get.text()
            //
            //    // Error, GET requests don't allow bodies!
            //    const copy = new Request('/example', {body});
            //
            // We return `undefined` when bodies are empty because it avoids
            // exceptions when the method does not allow bodies, and it should be
            // safe because:
            // - the HTTP protocol cannot differentiate null body from empty body
            // - the Fetch api coerces undefined bodies to empty.
            return body.size > 0 ? body : undefined;
        })
            .then(function (body) {
            // Using the two-argument Request constructor will copy everything in the
            // request except body, and may throw if the request to copy has elevated
            // privilege.
            //
            // Here we copy the request once to change the url, then again to set the
            // body. The body must be read asynchronously from the old request.
            var tokenRequest = new Request(addParam(request.url, 'id_token', token), request);
            return new Request(tokenRequest, { body: body });
        })
            .then(fetchFunction);
    }
    else {
        return fetchFunction(request);
    }
}
function fetchTokenAndAuthenticate(authData, url, endpoint, sentryOptions) {
    var _a;
    var fetchFunction = (_a = sentryOptions.fetchFunction) !== null && _a !== void 0 ? _a : globalFetch;
    var sentryUrl = (sentryOptions === null || sentryOptions === void 0 ? void 0 : sentryOptions.preserveRedirectUri) ? authData.authn_endpoint
        : replaceRedirectUri(authData.authn_endpoint, url);
    if (authData.no_cookie_token) {
        return fetchToken(sentryUrl, endpoint, sentryOptions).then(function (token) { return ({ token: token }); });
    }
    return fetchToken(sentryUrl, endpoint, sentryOptions)
        .then(function (token) { return authenticate(endpoint, fetchFunction, token); })
        .then(function (authentication) {
        if (authentication.is_authenticated) {
            return authentication;
        }
        throw new Error('Failed to authenticate');
    });
}
function fetchToken(url, endpoint, sentryOptions) {
    var _a;
    var fetchFunction = (_a = sentryOptions.fetchFunction) !== null && _a !== void 0 ? _a : globalFetch;
    return debounceRequest("sentry:" + endpoint, function () {
        return fetchFunction(url, { credentials: 'include' })
            .then(handleNotOk)
            .then(
        // 2XX response: text/plain response with id_token
        function (response) { return response.text(); }, 
        // other response: application/json response with step-up or other
        function (response) { return response.json().then(
        // response body is JSON
        function (jsonError) {
            if (jsonError.step_up_methods) {
                if (sentryOptions.followMidwayStepUp) {
                    var midwayStepUp = jsonError.step_up_methods.find(function (method) { return method.cap_name === MIDWAY_AUTH; });
                    if (midwayStepUp) {
                        return followMidwayStepUp(midwayStepUp, url, endpoint, sentryOptions);
                    }
                }
                else {
                    throw new Error(SentryError.NO_MIDWAY_SESSION);
                }
            }
            // response body is not step-up
            throw new Error(response.statusText);
        }, 
        // JSON parsing failed
        function () {
            throw new Error(response.statusText);
        }); });
    });
}
function buildQueryStringMap(url) {
    var queryString = url.split('?')[1];
    return queryString.split('&').reduce(function (queryStringMap, queryStringElement) {
        if (queryStringElement !== '') {
            var splitElement = queryStringElement.split('=');
            queryStringMap[splitElement[0]] = decodeURIComponent(splitElement[1]);
        }
        return queryStringMap;
    }, {});
}
function followMidwayStepUp(midwayStepUp, url, endpoint, sentryOptions) {
    var _a;
    var stepUpOptions = sentryOptions.followMidwayStepUpOptions, failOnInvalidSession = sentryOptions.failOnInvalidSession;
    var fetchFunction = (_a = sentryOptions.fetchFunction) !== null && _a !== void 0 ? _a : globalFetch;
    if (stepUpOptions) {
        // if configured, show auth modal instead of redirecting
        if (stepUpOptions.mode === 'modal') {
            var doFetchToken = function () { return debounceRequest("sentry:" + endpoint + ":fetch-token", function () { return fetchFunction(url, { credentials: 'include' }).then(handleNotOk).then(function (res) { return res.text(); }).catch(function (res) {
                // A 400 response from Midway indicates that the session is invalid for the client_id.
                // In such cases, Midway won't issue a token for the client_id on the call to "/SSO" even though the user login was successful.
                // When using step up with a modal, failure to handle an invalid session means that the user will be blocked indefinitely behind the modal dialog.
                // The modal will not be cleaned up even when the Midway popup is closed because the session is still invalid for the client_id.
                // This breaks the customer experience for applications that prefer to recover from a failed Midway login and take a different path.
                // The option "failOnInvalidSession" solves this problem. It signals the modal to be cleaned up on error and returns the appropriate
                // exception which the caller can handle.
                if (failOnInvalidSession && res instanceof Response && res.status == 400) {
                    throw exports.NO_MIDWAY_SESSION_ERROR;
                }
                return '';
            }); }); };
            var mode = stepUpOptions.mode, createModal = stepUpOptions.createModal, authModalOptions = __rest(stepUpOptions, ["mode", "createModal"]);
            return auth_modal_1.showAuthModal(midwayStepUp.cap_url, doFetchToken, authModalOptions, createModal).catch(function (err) {
                // if we receive a no midway session error, we should propagate it as is.
                if (err === exports.NO_MIDWAY_SESSION_ERROR) {
                    return Promise.reject(exports.NO_MIDWAY_SESSION_ERROR);
                }
                if (sentryOptions.debug) {
                    console.warn('[SentryFetch] An error ocurred while showing the auth modal.', err);
                }
                return Promise.reject(new Error(SentryError.MIDWAY_AUTH_MODAL_FAILED));
            });
        }
        // if configured, show confirmation dialog before redirect
        if (stepUpOptions.mode === 'confirm') {
            var msg = stepUpOptions.message || 'Your Midway session has expired. You will be redirected to Midway for authentication.';
            if (!window.confirm(msg)) {
                return Promise.reject(new Error(SentryError.MIDWAY_REDIRECT_CANCELLED));
            }
        }
    }
    var queryStringMap = buildQueryStringMap(url);
    var redirectUrl = '/SSO/redirect';
    queryStringMap['redirect_uri'] = window.location.href;
    queryStringMap['client_id'] = window.location.origin;
    if (typeof sentryOptions.followMidwayStepUp === 'string') {
        queryStringMap['acr_values'] = sentryOptions.followMidwayStepUp;
    }
    Object.keys(queryStringMap).forEach(function (queryParam) {
        redirectUrl = addParam(redirectUrl, queryParam, queryStringMap[queryParam]);
    });
    var midwayUrl = addParam(midwayStepUp.cap_url, 'next', redirectUrl);
    window.location.replace(midwayUrl);
    throw new Error(SentryError.MIDWAY_REDIRECT);
}
function authenticate(endpoint, fetchFunction, token) {
    return debounceRequest(endpoint, function () {
        return fetchFunction(addParam(endpoint + "/sso/login", 'id_token', token), { credentials: 'include' })
            .then(handleNotOk)
            .then(function (response) { return response.json(); })
            .catch(function (response) {
            throw new Error(response.statusText);
        });
    });
}
function handleNotOk(response) {
    if (!response.ok) {
        throw response;
    }
    return response;
}
var pendingRequests = {};
function debounceRequest(requestId, makeRequest) {
    if (pendingRequests[requestId]) {
        return pendingRequests[requestId];
    }
    var promise = makeRequest();
    pendingRequests[requestId] = promise;
    var unpend = function () { return delete pendingRequests[requestId]; };
    promise.then(unpend).catch(unpend);
    return promise;
}
var redirectUriParamRx = /&?redirect_uri=[^&]+/;
function replaceRedirectUri(url, value) {
    var base = url.replace(redirectUriParamRx, '');
    return addParam(base, 'redirect_uri', value);
}
function addParam(url, param, value) {
    if (!value) {
        return url;
    }
    var delim = url.includes('?') ? '&' : '?';
    return "" + url + delim + param + "=" + encodeURIComponent(value);
}
function isAuthenticated(endpoint) {
    var expiryTime = parseInt(sessionStorage.getItem(util_1.getSessionStorageKey(endpoint)), 10);
    return !isNaN(expiryTime) && new Date().getTime() < expiryTime;
}
function cacheAuthentication(endpoint, expiryTime) {
    var expiry = parseInt(expiryTime, 10);
    if (isNaN(expiry)) {
        return;
    }
    sessionStorage.setItem(util_1.getSessionStorageKey(endpoint), (expiry - util_1.CLOCK_SKEW).toString());
}
function clearAuthenticationCache(endpoint) {
    sessionStorage.removeItem(util_1.getSessionStorageKey(endpoint));
}
//# sourceMappingURL=index.js.map